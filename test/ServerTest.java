import networking.Protocol;
import org.junit.jupiter.api.*;

import java.io.*;
import java.net.*;

import static org.hamcrest.MatcherAssert.*;
import static org.hamcrest.CoreMatchers.*;
import static org.junit.jupiter.api.Assertions.*;

/**
 * JUnit test class for testing the functionality of the server in a server-client interaction using the Othello game protocol.
 * <p>
 * This class includes tests for server commands such as HELLO, LOGIN, LIST, QUEUE, NEWGAME, MOVE, GAMEOVER, and error handling.
 * <p>
 * Note: the test cases assume a running server with a known IP address ("192.168.178.69") and port (8080). Ensure that the server is running before executing these tests.
 * @author Dinh Thuy Nhat Vy
 * @version 1.0, 12/07/2023
 * @see networking.server.OthelloServer
 * @see Protocol
 * @see networking.exceptions.ClientUnavailableException
 */
class ServerTest {
    /**
     * Default constructor for the {@code ServerTest} class.
     * <p>
     * Note: this constructor is automatically generated by the compiler and is not intended for direct use.
     */
    @SuppressWarnings("unused")
    ServerTest() {}

    /**
     * Tests various server commands and their interactions with clients using sockets and the Othello game protocol.
     * <p>
     * Note: assume a running server with a known IP address ("192.168.178.69") and port (8080).
     */
    @Test
    void testServer() {
        Socket socket1;
        Socket socket2;
        try {
            socket1 = new Socket(InetAddress.getByName("192.168.178.69"), 8080);
            BufferedReader reader1 = new BufferedReader(new InputStreamReader(socket1.getInputStream()));
            final BufferedWriter writer1 = new BufferedWriter(new OutputStreamWriter(socket1.getOutputStream()));

            //Checks sendHello(ClientHandler clientHandler) method
            writer1.write(Protocol.HELLO + Protocol.SEPARATOR + "Tester Client");
            writer1.newLine();
            writer1.flush();
            assertThat(reader1.readLine(), containsString(Protocol.HELLO + Protocol.SEPARATOR));

            //Checks handleQueue(ClientHandler clientHandler) method when the first client hasn't logged in yet
            writer1.write(Protocol.QUEUE);
            writer1.newLine();
            writer1.flush();
            assertThat(reader1.readLine(), containsString(Protocol.ERROR)); //Returns an error since the first client hasn't logged in yet

            //Checks sendLogin(ClientHandler clientHandler, String clientUsername) method
            writer1.write(Protocol.LOGIN + Protocol.SEPARATOR + "Tester Client 1");
            writer1.newLine();
            writer1.flush();
            assertThat(reader1.readLine(), containsString(Protocol.LOGIN));
            writer1.write(Protocol.LOGIN + Protocol.SEPARATOR + "Tester Client 1 Again");
            writer1.newLine();
            writer1.flush();
            assertThat(reader1.readLine(), containsString(Protocol.ERROR)); //Returns an error since the first client has already logged in

            //Checks handleClientCommand(String receivedCommand) method when the first client sent an unknown command
            writer1.write("PLAY");
            writer1.newLine();
            writer1.flush();
            assertThat(reader1.readLine(), containsString(Protocol.ERROR)); //Returns an error since the first client sent an unknown command

            socket2 = new Socket(InetAddress.getByName("192.168.178.69"), 8080);
            BufferedReader reader2 = new BufferedReader(new InputStreamReader(socket2.getInputStream()));
            final BufferedWriter writer2 = new BufferedWriter(new OutputStreamWriter(socket2.getOutputStream()));
            writer2.write(Protocol.HELLO + Protocol.SEPARATOR + "Tester Client");
            writer2.newLine();
            writer2.flush();
            assertThat(reader2.readLine(), containsString(Protocol.HELLO + Protocol.SEPARATOR));

            //Checks handleMove(ClientHandler clientHandler, String clientInput) method when the second client hasn't logged in yet
            writer2.write(Protocol.MOVE + Protocol.SEPARATOR + "0");
            writer2.newLine();
            writer2.flush();
            assertThat(reader2.readLine(), containsString(Protocol.ERROR)); //RReturns an error since the second client hasn't logged in yet

            //Checks sendLogin(ClientHandler clientHandler, String clientUsername) method when the second client logs in with the same username as the first client
            writer2.write(Protocol.LOGIN + Protocol.SEPARATOR + "Tester Client 1");
            writer2.newLine();
            writer2.flush();
            assertThat(reader2.readLine(), containsString(Protocol.ALREADYLOGGEDIN));

            writer2.write(Protocol.LOGIN + Protocol.SEPARATOR + "Tester Client 2");
            writer2.newLine();
            writer2.flush();
            assertThat(reader2.readLine(), containsString(Protocol.LOGIN));

            //Checks sendList(ClientHandler clientHandler) method
            writer1.write(Protocol.LIST);
            writer1.newLine();
            writer1.flush();
            assertThat(reader1.readLine(), containsString(Protocol.LIST + Protocol.SEPARATOR + "Tester Client 1" + Protocol.SEPARATOR + "Tester Client 2"));

            //Checks handleMove(ClientHandler clientHandler, String clientInput) method when the second client is not currently in a game
            writer2.write(Protocol.MOVE + Protocol.SEPARATOR + "0");
            writer2.newLine();
            writer2.flush();
            assertThat(reader2.readLine(), containsString(Protocol.ERROR)); //Returns an error since the second client is not currently in a game

            //Checks handleQueue(ClientHandler clientHandler) and sendNewGame(ClientHandler clientHandler1, ClientHandler clientHandler2) methods
            writer1.write(Protocol.QUEUE);
            writer1.newLine();
            writer1.flush();
            writer2.write(Protocol.QUEUE);
            writer2.newLine();
            writer2.flush();
            String answer1 = reader1.readLine();
            String answer2 = reader2.readLine();
            assertThat(answer1, containsString(Protocol.NEWGAME + Protocol.SEPARATOR + "Tester Client 1" + Protocol.SEPARATOR + "Tester Client 2"));
            assertThat(answer2, containsString(Protocol.NEWGAME + Protocol.SEPARATOR + "Tester Client 1" + Protocol.SEPARATOR + "Tester Client 2"));
            writer1.write(Protocol.QUEUE);
            writer1.newLine();
            writer1.flush();
            assertThat(reader1.readLine(), containsString(Protocol.ERROR)); //Returns an error since the first client is currently in a game

            //Checks handleMove(ClientHandler clientHandler, String clientInput) method
            writer2.write(Protocol.MOVE + Protocol.SEPARATOR + "0");
            writer2.newLine();
            writer2.flush();
            assertThat(reader2.readLine(), containsString(Protocol.ERROR)); //Returns an error since this is not the second client's turn
            writer1.write(Protocol.MOVE + Protocol.SEPARATOR + "0");
            writer1.newLine();
            writer1.flush();
            assertThat(reader1.readLine(), containsString(Protocol.ERROR)); //Returns an error since 0 is an invalid move in this case
            writer1.write(Protocol.MOVE + Protocol.SEPARATOR + "26");
            writer1.newLine();
            writer1.flush();
            assertThat(reader1.readLine(), containsString(Protocol.MOVE + Protocol.SEPARATOR + "26"));
            assertThat(reader2.readLine(), containsString(Protocol.MOVE + Protocol.SEPARATOR + "26"));
            writer2.write(Protocol.MOVE + Protocol.SEPARATOR + "64");
            writer2.newLine();
            writer2.flush();
            assertThat(reader2.readLine(), containsString(Protocol.ERROR)); //Returns an error since the second client still has possible move(s)

            //Checks sendGameOver(ClientHandler clientHandler1, ClientHandler clientHandler2, String reason, String winner) method
            reader2.close();
            writer2.close();
            socket2.close();
            assertThat(reader1.readLine(), containsString(Protocol.GAMEOVER + Protocol.SEPARATOR + Protocol.DISCONNECT + Protocol.SEPARATOR + "Tester Client 1"));

            //Tests ClientUnavailableException
            writer1.write(Protocol.LIST);
            writer1.newLine();
            writer1.flush();
            assertFalse(reader1.readLine().contains("Tester Client 2"));

            reader1.close();
            writer1.close();
            socket1.close();
        } catch (IOException e) {}
    }
}