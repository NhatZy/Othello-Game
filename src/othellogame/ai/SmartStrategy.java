package othellogame.ai;

import othellogame.model.*;

import java.util.*;

/**
 * Represents a smart strategy for a computer player in the Othello game.
 * <p>
 * The smart strategy uses the minimax algorithm with alpha-beta pruning to determine the best move based on a heuristic evaluation function.
 * @author Dinh Thuy Nhat Vy
 * @version 1.0, 12/07/2023
 * @see Strategy
 * @see Move
 * @see Game
 */
public class SmartStrategy implements Strategy {
    /**
     * The name of the smart strategy.
     */
    private String name = "Smart AI";

    /**
     * The maximum value used in the minimax algorithm for scoring purpose.
     */
    private final double MAX = 1000000;

    /**
     * Default constructor for the {@code SmartStrategy} class.
     * <p>
     * Note: this constructor is automatically generated by the compiler and is not intended for direct use.
     */
    public SmartStrategy() {}

    /**
     * Gets the name of the smart strategy.
     * @return the name of the smart strategy.
     */
    @Override
    public String getStrategy() {
        return name;
    }

    /**
     * Determines the best move for the computer player using the minimax algorithm with alpha-beta pruning.
     * @param game the current Othello game.
     * @return the best move determined by the smart strategy.
     */
    @Override
    public Move determineMove(Game game) {
        OthelloGame othelloGame = (OthelloGame) game;
        double bestScore;
        Move bestMove = null;
        List<Move> moveList = othelloGame.getValidMoves();
        if (game.isFirstPlayerTurn()) {
            bestScore = -MAX;
            for (Move currentMove : moveList) {
                OthelloGame copiedGame = othelloGame.deepCopy();
                copiedGame.doMove(currentMove);
                double currentScore = miniMax(copiedGame, 0, false);
                if (currentScore >= bestScore) {
                    bestScore = currentScore;
                    bestMove = currentMove;
                }
            }
        } else {
            bestScore = MAX;
            for (Move currentMove : moveList) {
                OthelloGame copiedGame = othelloGame.deepCopy();
                copiedGame.doMove(currentMove);
                double currentScore = miniMax(copiedGame, 0, true);
                if (currentScore <= bestScore) {
                    bestScore = currentScore;
                    bestMove = currentMove;
                }
            }
        }
        return bestMove;
    }

    /**
     * Calculate the heuristic score for the given game.
     * @param game the current Othello game.
     * @return the heuristic score.
     */
    private double heuristic(Game game) {
        double totalScore;
        totalScore = game.calculateHeuristicScore();
        return totalScore;
    }

    /**
     * Executes the minimax algorithm with alpha-beta pruning.
     * @param game the current Othello game.
     * @param depth the current depth in the search tree.
     * @param maximizingPlayer indicates whether the player is maximizing or minimizing.
     * @return the score of the best move.
     */
    private double miniMax(Game game, int depth, boolean maximizingPlayer) {
        return alphaBeta(game, depth, -MAX, MAX, maximizingPlayer);
    }

    /**
     * Executes the minimax algorithm with alpha-beta pruning.
     * @param game the current Othello game.
     * @param depth the current depth in the search tree.
     * @param a the alpha value.
     * @param b the beta value.
     * @param maximizingPlayer indicates whether the player is maximizing or minimizing.
     * @return the score of the best move.
     */
    private double alphaBeta(Game game, int depth, double a, double b, boolean maximizingPlayer) {
        if (depth == 5) {
            return heuristic(game);
        }
        if (game.isGameOver()) {
            if (game.getWinner() == Mark.BLACK) {
                return MAX;
            } else if (game.getWinner() == Mark.WHITE) {
                return -MAX;
            } else {
                return 0;
            }
        }
        double bestScore;
        List<Move> moveList = game.getValidMoves();
        if (maximizingPlayer) {
            bestScore = -MAX;
            if (moveList.isEmpty()) {
                game.swapTurn();
                return alphaBeta(game, depth + 1, a, b, false);
            }
            for (Move currentMove : moveList) {
                Game copiedGame = game.deepCopy();
                copiedGame.doMove(currentMove);
                double currentScore = alphaBeta(copiedGame, depth + 1, a, b, false);
                bestScore = Math.max(bestScore, currentScore);
                a = Math.max(a, currentScore);
                if (a >= b) {
                    break;
                }
            }
        } else {
            bestScore = MAX;
            if (moveList.isEmpty()) {
                game.swapTurn();
                return alphaBeta(game, depth + 1, a, b, true);
            }
            for (Move currentMove : moveList) {
                Game copiedGame = game.deepCopy();
                copiedGame.doMove(currentMove);
                double currentScore = alphaBeta(copiedGame, depth + 1, a, b, true);
                bestScore = Math.min(bestScore, currentScore);
                b = Math.min(b, currentScore);
                if (a >= b) {
                    break;
                }
            }
        }
        return bestScore;
    }
}