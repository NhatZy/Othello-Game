package othellogame.ui;

import javafx.animation.*;
import javafx.util.*;
import othellogame.ai.*;
import othellogame.model.*;

import java.util.*;

/**
 * Represents the model of the Othello game application, following the Model-View-Controller (MVC) pattern.
 * <p>
 * Manages the game logic, player interactions, and game state.
 * <p>
 * This class interacts with the game state ({@link OthelloGame}), player entities ({@link AbstractPlayer}) and the application controller ({@link Controller}). It handles the creation of the game, player moves, and game outcomes. The {@link HumanPlayer} and {@link ComputerPlayer} are created based on user input, and the game state is updated according to player moves.
 * <p>
 * Additionally, this class communicates with the "Controller" to update the view and manage the overall flow of the game.
 * @author Dinh Thuy Nhat Vy
 * @version 1.0, 12/07/2023
 * @see OthelloGame
 * @see AbstractPlayer
 * @see Mark
 * @see ComputerPlayer
 * @see NaiveStrategy
 * @see SmartStrategy
 * @see HumanPlayer
 * @see Controller
 * @see Move
 */
public class Model {
    /**
     * Represents the core Othello game instance managed by this model.
     */
    private OthelloGame game;

    /**
     * Represents the first player in the Othello game.
     */
    private AbstractPlayer player1;

    /**
     * Represents the second player in the Othello game.
     */
    private AbstractPlayer player2;

    /**
     * Represents the player currently making a move in the Othello game.
     */
    private AbstractPlayer currentPlayer;

    /**
     * Default constructor for the {@code Model} class.
     * <p>
     * Note: this constructor is automatically generated by the compiler and is not intended for direct use.
     */
    Model() {}

    /**
     * Creates a new Othello game with the specified player usernames.
     * <p>
     * Initializes player instances and the game board.
     * @param firstPlayerUsername first player's username.
     * @param secondPlayerUsername second player's username.
     */
    public void createNewGame(String firstPlayerUsername, String secondPlayerUsername) {
        this.player1 = createPlayer(firstPlayerUsername, Mark.BLACK);
        this.player2 = createPlayer(secondPlayerUsername, Mark.WHITE);
        this.game = new OthelloGame(player1, player2);
        updateCurrentPlayerAnnouncement();
    }

    /**
     * Creates a player instance based on the specified name and mark.
     * @param name the name of the player.
     * @param mark the mark associated with the player.
     * @return a player instance.
     */
    private AbstractPlayer createPlayer(String name, Mark mark) {
        if (name.equalsIgnoreCase("-N")) {
            return new ComputerPlayer(new NaiveStrategy(), mark);
        } else if (name.equalsIgnoreCase("-S")) {
            return new ComputerPlayer(new SmartStrategy(), mark);
        } else {
            return new HumanPlayer(name, mark);
        }
    }

    /**
     * Updates the current player announcement and performs actions based on the game state.
     */
    private void updateCurrentPlayerAnnouncement() {
        this.currentPlayer = (AbstractPlayer) game.getTurn();
        if (game.getValidMoves().isEmpty()) {
            game.swapTurn();
            this.currentPlayer = (AbstractPlayer) game.getTurn();
            Controller.getInstance().updateCurrentPlayerAnnouncement(currentPlayer.getMark(), currentPlayer.getName());
        } else {
            Controller.getInstance().updateCurrentPlayerAnnouncement(currentPlayer.getMark(), currentPlayer.getName());
        }
        if (currentPlayer instanceof ComputerPlayer) {
            Move botMove = currentPlayer.determineMove(game);
            updateCurrentMove(((OthelloMove) botMove).getIndex());
        }
    }

    /**
     * Handles the player's move, updates the game board, and checks for game completion.
     * @param index the index of the move.
     */
    public void updateCurrentMove(int index) {
        Move currentMove = new OthelloMove(currentPlayer.getMark(), index);
        if (game.isValidMove(currentMove)) {
            Controller.getInstance().updateCurrentMoveAnnouncement(true, currentPlayer.getName(), currentPlayer.getMark(), index);
            Controller.getInstance().updateBoard(true, ((OthelloMove) currentMove).getMark(), index);
            game.doMove(currentMove);
            List<Integer> fieldsToFlip = new ArrayList<>();
            for (int i = 0; i < game.getFieldsToFlipList().size(); i++) {
                for (int j = 0; j < game.getFieldsToFlipList().get(i).size(); j++) {
                    fieldsToFlip.add(game.getFieldsToFlipList().get(i).get(j));
                }
            }
            for (Integer indexToFlip : fieldsToFlip) {
                Controller.getInstance().updateBoard(false, ((OthelloMove) currentMove).getMark(), indexToFlip);
            }
            if (!game.isGameOver()) {
                PauseTransition pause = new PauseTransition(Duration.seconds(0.5));
                pause.setOnFinished(e -> updateCurrentPlayerAnnouncement());
                pause.play();
            } else {
                updatePlayersResults();
            }
        } else {
            Controller.getInstance().updateCurrentMoveAnnouncement(false, null, null, index);
        }
    }

    /**
     * Updates the players' results based on the game outcome and ends the game.
     */
    private void updatePlayersResults() {
        Controller.getInstance().updatePlayersResults(false, 0, player1.getName(), game.countBlack(), null, null);
        Controller.getInstance().updatePlayersResults(false, 1, player2.getName(), game.countWhite(), null, null);
        if (game.getWinner() == Mark.BLACK) {
            Controller.getInstance().updatePlayersResults(true, -1, player1.getName(), -1, Mark.BLACK, null);
        } else if (game.getWinner() == Mark.WHITE) {
            Controller.getInstance().updatePlayersResults(true, -1, player2.getName(), -1, Mark.WHITE, null);
        } else {
            Controller.getInstance().updatePlayersResults(true, -1, null, -1, Mark.EMPTY, null);
        }
        Controller.getInstance().endGame();
    }

    /**
     * Handles quitting the game, updating results accordingly, and ending the game.
     */
    public void handleQuitGame() {
        if (currentPlayer.getName().equals(player1.getName())) {
            Controller.getInstance().updatePlayersResults(true, -2, player2.getName(), -1, player2.getMark(), player1.getName());
        } else if (currentPlayer.getName().equals(player2.getName())) {
            Controller.getInstance().updatePlayersResults(true, -2, player1.getName(), -1, player1.getMark(), player2.getName());
        }
        Controller.getInstance().endGame();
    }
}