package othellogame.ui.view;

import javafx.fxml.*;
import javafx.scene.*;
import javafx.scene.control.*;
import javafx.scene.effect.*;
import javafx.scene.image.*;
import javafx.scene.input.*;
import javafx.scene.layout.*;
import javafx.scene.paint.*;
import javafx.scene.shape.*;
import javafx.scene.text.*;
import javafx.stage.*;
import othellogame.model.*;
import othellogame.ui.*;

import java.io.*;
import java.util.*;

/**
 * Represents the controller for the {@code OfflinePlayingMainScene} FXML file in the Othello game application.
 * <p>
 * It handles the main playing scene, player information, game announcements, and user interactions.
 * <p>
 * Follows the Model-View-Controller (MVC) pattern.
 * @author Dinh Thuy Nhat Vy
 * @version 1.0, 12/07/2023
 * @see Board
 * @see Controller
 * @see Mark
 */
public class OfflinePlayingMainView {
    /**
     * The resource bundle for localization and internationalization.
     */
    private ResourceBundle bundle;

    /**
     * The main pane containing the components of the {@code OfflinePlayingMainScene}.
     */
    @FXML
    public Pane mainOfflinePlaying;

    /**
     * Text displaying the username of the first player.
     */
    @FXML
    private Text firstPlayerUsername;

    /**
     * Text displaying the username of the second player.
     */
    @FXML
    private Text secondPlayerUsername;

    /**
     * ImageView displaying the avatar of the first player.
     */
    @FXML
    private ImageView firstPlayerAvatar;

    /**
     * ImageView displaying the avatar of the second player.
     */
    @FXML
    private ImageView secondPlayerAvatar;

    /**
     * TextArea for displaying game announcements.
     */
    @FXML
    private TextArea announcement;

    /**
     * GridPane representing the game board.
     */
    @FXML
    private GridPane board;

    /**
     * List of Rectangles representing individual cells on the game board.
     */
    @FXML
    private List<Rectangle> grids;

    /**
     * List of StackPanes representing the positions for discs on the game board.
     */
    @FXML
    private List<StackPane> stackPanes;

    /**
     * The radius of the discs on the board.
     */
    private static final double DISC_RADIUS = 24.5;

    /**
     * Group containing the announcement box UI elements.
     */
    @FXML
    private Group announcementBox;

    /**
     * Group containing the leave match confirmation dialog UI elements.
     */
    @FXML
    private Group leaveMatchQuestion;

    /**
     * ImageView representing the sound icon in the main offline playing view.
     */
    @FXML
    public ImageView soundIcon;

    /**
     * Default constructor for the {@code OfflinePlayingMainView} class.
     * <p>
     * Note: this constructor is automatically generated by the compiler and is not intended for direct use.
     */
    public OfflinePlayingMainView() {}

    /**
     * Loads the {@code OfflinePlayingMainScene} FXML file and initializes the necessary components.
     * @param currentPane the current pane from which the {@code OfflinePlayingMainScene} is loaded.
     */
    public void loadOfflinePlayingMainScene(Pane currentPane) {
        try {
            this.bundle = ResourceBundle.getBundle("othellogame.ui.languages", Locale.getDefault());
            FXMLLoader loader = new FXMLLoader();
            Stage stage = (Stage) currentPane.getScene().getWindow();
            loader.setLocation(getClass().getResource("OfflinePlayingMainScene.fxml"));
            loader.setResources(bundle);
            loader.setController(this);
            Parent root = loader.load();
            stage.getScene().setRoot(root);
            updatePlayersInfo();
            for (int i = 0; i < 64; i++) {
                if (i == 27 || i == 28 || i == 35 || i == 36) {
                    continue;
                }
                StackPane currentStackPane = stackPanes.get(i);
                GridPane.setRowIndex(currentStackPane, i / Board.DIM);
                GridPane.setColumnIndex(currentStackPane, i % Board.DIM);
                Text index = new Text(Integer.toString(i));
                index.setStyle("-fx-font-family: 'Comic Sans MS'; -fx-font-size: 16.0; -fx-font-style: italic; -fx-alignment: CENTER; -fx-fill: black; -fx-font-weight: 700");
                currentStackPane.getChildren().add(index);
                currentStackPane.setMouseTransparent(true);
            }
        } catch (IOException e) {
            System.out.println("ERROR: [OfflinePlayingMainScene] - " + e.getMessage());
        }
    }

    /**
     * Updates player information. This method retrieves the avatars and usernames of the 2 players participating in the offline Othello game and displays this information on the user interface.
     */
    private void updatePlayersInfo() {
        String firstUsername = OfflinePlayingView.firstUsername, secondUsername = OfflinePlayingView.secondUsername;
        ResourceBundle bundle = ResourceBundle.getBundle("othellogame.ui.languages", Locale.getDefault());
        if (firstUsername.equalsIgnoreCase("-N")) {
            this.firstPlayerUsername.setText(bundle.getString("naiveAI") + " " + bundle.getString("markBlack"));
        } else if (firstUsername.equalsIgnoreCase("-S")) {
            this.firstPlayerUsername.setText(bundle.getString("smartAI") + " " + bundle.getString("markBlack"));
        } else {
            this.firstPlayerUsername.setText(firstUsername + " " + bundle.getString("markBlack"));
        }
        if (secondUsername.equalsIgnoreCase("-N")) {
            this.secondPlayerUsername.setText(bundle.getString("naiveAI") + " " + bundle.getString("markWhite"));
        } else if (secondUsername.equalsIgnoreCase("-S")) {
            this.secondPlayerUsername.setText(bundle.getString("smartAI") + " " + bundle.getString("markWhite"));
        } else {
            this.secondPlayerUsername.setText(secondUsername + " " + bundle.getString("markWhite"));
        }
        this.firstPlayerAvatar.setImage(OfflinePlayingView.firstAvatar);
        this.secondPlayerAvatar.setImage(OfflinePlayingView.secondAvatar);
    }

    /**
     * Handles the click event for the "Game Instructions" button.
     */
    @FXML
    private void onInstructionsClick() {
        Controller.previousScene = "offlinePlayingMain";
        Controller.getInstance().loadScene("gameInstructions", mainOfflinePlaying);
    }

    /**
     * Updates the current player announcement.
     * @param mark the mark of the current player.
     * @param name the name of the current player.
     */
    public void updateCurrentPlayerAnnouncement(Mark mark, String name) {
        String currentPlayerAnnouncement;
        if (mark == Mark.BLACK) {
            currentPlayerAnnouncement = bundle.getString("currentPlayer") + " " + name + " " + bundle.getString("markBlack") + ".";
        } else {
            currentPlayerAnnouncement = bundle.getString("currentPlayer") + " " + name + " " + bundle.getString("markWhite") + ".";
        }
        this.announcement.appendText(currentPlayerAnnouncement + "\n");
    }

    /**
     * Handles the mouse click event on the game board for making moves.
     * @param e the MouseEvent triggered by the player.
     */
    @FXML
    private void handleMove(MouseEvent e) {
        Rectangle clickedGrid = (Rectangle) e.getSource();
        int index = grids.indexOf(clickedGrid);
        Controller.getInstance().handleMove(index);
    }

    /**
     * Updates the announcement box with the details of the current move.
     * @param validMove true if the move is valid, false otherwise.
     * @param name the name of the player making the move.
     * @param mark the mark of the player making the move.
     * @param index the index of the move on the game board.
     */
    public void updateCurrentMoveAnnouncement(boolean validMove, String name, Mark mark, int index) {
        String currentMoveAnnouncement;
        if (validMove) {
            if (mark == Mark.BLACK) {
                currentMoveAnnouncement = bundle.getString("player") + " " + name + " " + bundle.getString("markBlack") + " " + bundle.getString("placedDiscAnnouncement") + " " + index + " " + bundle.getString("row") + " " + index / Board.DIM + " " + bundle.getString("col") + " " + index % Board.DIM + ").";
            } else {
                currentMoveAnnouncement = bundle.getString("player") + " " + name + " " + bundle.getString("markWhite") + " " + bundle.getString("placedDiscAnnouncement") + " " + index + " " + bundle.getString("row") + " " + index / Board.DIM + " " + bundle.getString("col") + " " + index % Board.DIM + ").";
            }
        } else {
            currentMoveAnnouncement = index + " " + bundle.getString("invalidMoveAnnouncement");
        }
        this.announcement.appendText(currentMoveAnnouncement + "\n");
    }

    /**
     * Updates the game board with the latest move.
     * @param addDisc true if a new disc is added, false if an existing disc is flipped.
     * @param mark the mark (BLACK or WHITE) associated with the disc being added or flipped.
     * @param index the index on the game board where the disc is added or flipped.
     */
    public void updateBoard(boolean addDisc, Mark mark, int index) {
        StackPane currentStackPane = stackPanes.get(index);
        if (addDisc) {
            currentStackPane.getChildren().removeIf(node -> node instanceof Text);
            Circle disc = new Circle(DISC_RADIUS);
            disc.setStrokeWidth(2.5);
            DropShadow dropShadow = new DropShadow();
            dropShadow.setRadius(5.0);
            dropShadow.setOffsetX(3);
            dropShadow.setOffsetY(3);
            if (mark == Mark.BLACK) {
                disc.setStyle("-fx-stroke: black; -fx-fill: linear-gradient(to top right, #000000, #111111, #222222, #333333, #444444, #555555)");
                dropShadow.setColor(Color.web("#1f1f1f80"));
            } else {
                disc.setStyle("-fx-stroke: white; -fx-fill: linear-gradient(to top right, #8c8c8c, #a0a1a0, #b5b5b5, #c9cac9, #dedede, #f2f3f2)");
                dropShadow.setColor(Color.web("#1f1f1f"));
            }
            disc.setEffect(dropShadow);
            currentStackPane.getChildren().add(disc);
            grids.get(index).setCursor(Cursor.DEFAULT);
        } else {
            currentStackPane.getChildren().removeIf(node -> node instanceof Circle);
            Circle newFlippedDisc = new Circle(DISC_RADIUS);
            newFlippedDisc.setStrokeWidth(2.5);
            DropShadow otherMarkDropShadow = new DropShadow();
            otherMarkDropShadow.setRadius(5.0);
            otherMarkDropShadow.setOffsetX(3);
            otherMarkDropShadow.setOffsetY(3);
            if (mark == Mark.BLACK) {
                newFlippedDisc.setStyle("-fx-stroke: black; -fx-fill: linear-gradient(to top right, #000000, #111111, #222222, #333333, #444444, #555555)");
                otherMarkDropShadow.setColor(Color.web("#1f1f1f80"));
            } else {
                newFlippedDisc.setStyle("-fx-stroke: white; -fx-fill: linear-gradient(to top right, #8c8c8c, #a0a1a0, #b5b5b5, #c9cac9, #dedede, #f2f3f2)");
                otherMarkDropShadow.setColor(Color.web("#1f1f1f"));
            }
            newFlippedDisc.setEffect(otherMarkDropShadow);
            currentStackPane.getChildren().add(newFlippedDisc);
        }
    }

    /**
     * Handles the click event for the quit button, prompting a confirmation dialog.
     */
    @FXML
    private void onQuitClick() {
        this.announcementBox.setOpacity(0.09);
        this.board.setOpacity(0.04);
        this.leaveMatchQuestion.setVisible(true);
    }

    /**
     * Handles the click event for the close icon on the leave match confirmation dialog.
     */
    @FXML
    private void onCloseIconClick() {
        this.leaveMatchQuestion.setVisible(false);
        this.announcementBox.setOpacity(1.0);
        this.board.setOpacity(1.0);
    }

    /**
     * Handles the click event for the yes button on the leave match confirmation dialog.
     */
    @FXML
    private void onYesBtnClick() {
        Controller.getInstance().handleQuitGame();
    }

    /**
     * Controls the game sound, toggling between on and off states.
     */
    @FXML
    public void gameSoundControl() {
        Controller.getInstance().gameSoundControl();
    }
}